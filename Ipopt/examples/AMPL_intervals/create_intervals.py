import subprocess
import sys
import random

class Interval:
    """Representation of upper and lower bound"""
    def __init__(self, pL, pU):
        assert(len(pL)==len(pU))
        self.pL = pL
        self.pU = pU

    def split(self, idx):
        """
        split an interval along the variable dimension idx (in which notation - 1based or 0based?)

        in: parameter index, which is split,
        out: 2 intervals resulting from split
        """
        p1L = []
        p1U = []
        p2L = []
        p2U = []
        for k, (pLv, pUv) in enumerate(zip(self.pL, self.pU)):
            p1L.append(pLv)
            p2U.append(pUv)
            if k==idx:
                v = 0.5*(pLv+pUv)
                p1U.append(v)
                p2L.append(v)
            else:
                p1U.append(pUv)
                p2L.append(pLv)
        return Interval(p1L, p1U), Interval(p2L, p2U)

class AmplSet:
    """an ampl setup: ampl srcipt and feasible set of intervals"""
    def __init__(self, ampl_script, pLnames, pUnames, pLvalues, pUvalues):
        self.ampl_script = ampl_script
        self.pLnames = pLnames
        self.pUnames = pUnames
        self.pLvalues = pLvalues
        self.pUvalues = pUvalues
        self.intervals = [Interval(pLvalues, pUvalues)]

    def write_include_file(self, filename='intervalls.inc'):
        """write current intervallization data into ampl include file"""
        f = open(filename, 'w')
        nint = len(self.intervals)
        f.write('#file generated by sIpOpt intervallization routine script create_intervals.py -- Ben Waldecker Sep 2012\n\n');
        f.write('let nint := {};\n'.format(nint))
        for nameL, nameU,k in zip(self.pLnames, self.pUnames, range(len(self.pLnames))):
            f.write('let {{q in 1..{} }} {}[q].intervalID := q;\n'.format(nint, nameL))
            f.write('let {{q in 1..{} }} {}[q].parameter := {};\n'.format(nint,nameL, k+1))
            f.write('let {{q in 1..{} }} {}[q].intervalID := q;\n'.format(nint, nameU))
            f.write('let {{q in 1..{} }} {}[q].parameter := {};\n'.format(nint, nameU, k+1))

        for k, iv in enumerate(self.intervals):
            for nameL, pL, nameU, pU in zip(self.pLnames, iv.pL, self.pUnames, iv.pU):
                f.write('let {}[{}] := {};\n'.format(nameL, k+1, pL))
                f.write('let {}[{}] := {};\n'.format(nameU, k+1, pU))
        f.write('\n\n#end of file');
        f.close()

    def call_ampl(self, output_file_handle=None):
        """"
        one run of ampl

        write inc file and run ampl with the specified setup
        """
        self.write_include_file()
        try:
            subprocess.check_call(['ampl', self.ampl_script], stdout=output_file_handle)
        except subprocess.CalledProcessError as e:
            print e
            sys.exit(1)

    def split(self, interval_idx, para_idx):
        """split interval at interval_idx with respect to parameter para_idx"""
        split_interval = self.intervals.pop(interval_idx)
        interval1, interval2 = split_interval.split(para_idx)
        self.intervals.extend([interval1, interval2])

    def randomize(self,nruns):
        for ir in range(nruns):
            output_f = open('output'+str(ir)+'.txt', 'w')
            self.call_ampl(output_file_handle=output_f)
            output_f.close()
            nint = random.randint(0,(len(self.intervals)-1))
            npar = random.randint(0,(len(self.pLnames)-1))
            self.split(nint,npar)
            print 'In Durchgang {} wurde Intervall {} und dort Parameter {} gesplittet!'.format(ir+1,nint+1,npar+1)


def run():
    ampl_script = 'autorandomintervals.run'
    pLnames = ['p1L', 'p2L']
    pUnames = ['p1U', 'p2U']
    pLvalues = [0.9, 0.8]
    pUvalues = [1.1, 1.2]
    info = AmplSet(ampl_script, pLnames, pUnames, pLvalues, pUvalues)
    info.randomize(8)

if __name__=='__main__':
    run()
